# Single Responsibility Principle
* A class should have one, and only one, reason to change.
* Each class only does one thing and every class or module only has responsibility for one part of the software’s functionality
* More simply, each class should solve only one problem.
# Open-Closed Principle
* You should be able to extend a class’s behavior without modifying it
* Open for extension, Closed for modification.
* Open for extension, meaning that the class’s behavior can be extended.
* Closed for modification, meaning that the source code is set and cannot be changed.
# Liskov Substitution Principle
* Every derived class should be substitutable for its parent class
* It says when we refer a child class object using the datatype of parent class, there should not be any unexpected behaviour.
# Interface Segregation Principle
* Make fine grained interfaces that are client-specific. Clients should not be forced to implement interfaces they do not use.
# Dependency Inversion Principle
* Depend on abstractions, not on concretions
* High level modules should not depend upon low level modules. Both should depend on abstractions.
* Abstractions should not depend on details. Details should depend upon abstractions.

# NOTE:

To understand the problem first read the files of inefficient folder then you will find the solution in efficient folder where particular principle is used to solve that problem.
<br><br>Try to read the files of inefficient and efficient folder in sequential order.  </font>
